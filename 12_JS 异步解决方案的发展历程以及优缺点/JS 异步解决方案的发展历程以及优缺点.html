<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=q">
  <title>JS 异步解决方案的发展历程以及优缺点</title>
</head>
<body>
  <script>
    // https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/11
    // 1 generate
    function* gen() {
      yield console.log(1)
      yield console.log(2)
      yield console.log(3)
      return 'end'
    }
    let g = gen()
    g.next() // 1
    g.next() // 2
    g.next() // 3
    console.log(g.next()) // {value: 'end', done: true}

    // 2 Promise
    /* 
      Promise就是为了解决callback的问题而产生的。
      Promise 实现了链式调用，也就是说每次 then 后返回的都是一个全新 Promise，
      如果我们在 then 中 return ，return 的结果会被 Promise.resolve() 包装
      优点：解决了回调地狱的问题 */
      var a = 0
      var b = () => {
        var temp = a;
        Promise.resolve(10)
          .then((r) => {
            a = temp + r;
          })
          .then(() => {
            console.log('2', a)
          })
      }
      b()
      a++
      console.log('1', a)

    // 3 回调函数
      /* 缺点：回调地狱，不能用 try catch 捕获错误，不能 return
        回调地狱的根本问题在于：
        缺乏顺序性： 回调地狱导致的调试困难，和大脑的思维方式不符
        嵌套函数存在耦合性，一旦有所改动，就会牵一发而动全身，即（控制反转）
        嵌套函数过多的多话，很难处理错误 */

    /* 
      4. Async/await
      async、await 是异步的终极解决方案
      优点：代码清晰，不用像 Promise 写一大堆 then 链，处理了回调地狱的问题
      缺点：await 将异步代码改造成同步代码，如果多个异步操作没有依赖性而使用 await 会导致性能上的降低。 */
  </script>
</body>
</html>