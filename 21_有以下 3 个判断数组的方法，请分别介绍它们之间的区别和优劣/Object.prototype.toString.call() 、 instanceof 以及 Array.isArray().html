<<<<<<< HEAD
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <script type="text/javascript">
    /* 
      有以下 3 个判断数组的方法，请分别介绍它们之间的区别和优劣
      Object.prototype.toString.call() 、 instanceof 以及 Array.isArray() 
    */
    // 1. typeof
    typeof ''; // string 有效
    typeof 1; // number 有效
    typeof Symbol(); // symbol 有效
    typeof true; //boolean 有效
    typeof undefined; //undefined 有效
    typeof null; //object 无效
    typeof []; //object 无效
    typeof new Function(); // function 有效
    typeof new Date(); //object 无效
    typeof new RegExp(); //object 无效
   
    // 2. instanceof  检测的是原型
      // instanceof 只能用来判断两个对象是否属于实例关系， 而不能判断一个对象实例具体属于哪种类型。
    function Person() {};
    [] instanceof Array // true
    new Date() instanceof Date; // true
    new Person() instanceof Person;
    [1, 2, 3] instanceof Object; // true
    new Date() instanceof Object; // true
    new Person instanceof Object; // true
    console.log({} instanceof Object)
      // instanceof 存在的问题 来自于不同框架的 array 拥有不同的构造器 这就不能判断啦
    let iframe = document.createElement('iframe')
    document.body.appendChild(iframe)
    xArray = window.frames[0].Array  // window.frames[0]是另外一个页面的window
    xArr = new xArray()
    xArr.push(1, 2, 3) // xArr = [1, 2, 3]
    xArr instanceof Array // false 因为是另一个window的Array构造器创建的数组 

    // 3. Array.isArray() ES5 推出的
    Array.isArray(xArr)  // true 这个方法可以用来判断 不同window下创建的数组
    
    // 4. Object.prototype.toString.call() 都可以判断出来哦
    Object.prototype.toString.call('') ;            // [object String]
    Object.prototype.toString.call(1) ;             // [object Number]
    Object.prototype.toString.call(true) ;          // [object Boolean]
    Object.prototype.toString.call(Symbol());       //[object Symbol]
    Object.prototype.toString.call(undefined) ;     // [object Undefined]
    Object.prototype.toString.call(null) ;          // [object Null]
    Object.prototype.toString.call(new Function()) ;// [object Function]
    Object.prototype.toString.call(new Date()) ;    // [object Date]
    Object.prototype.toString.call([]) ;            // [object Array]
    Object.prototype.toString.call(new RegExp()) ;  // [object RegExp]
    Object.prototype.toString.call(new Error()) ;   // [object Error]
    Object.prototype.toString.call(document) ;      // [object HTMLDocument]
    Object.prototype.toString.call(window) ;        //[object global] window 是全局对象 global 的引用

    // 5. constructor
    /* 
      1. null 和 undefined 是无效的对象，因此是不会有 constructor 存在的，
          这两种类型的数据需要通过其他方式来判断。
      2. 函数的 constructor 是不稳定的，这个主要体现在自定义对象上，
          当开发者重写 prototype 后，原有的 constructor 引用会丢失，constructor 会默认为 Object
     */
    let p = new Person()
    console.log(p.constructor) // ƒ Person() {}
    console.log(p.constructor === Person) // true
    let num = 1
    console.log(num.constructor === Number) // true
    function foo() {}
    console.log(foo.constructor === Function) // true
    console.log(true.constructor === Boolean) // true
    console.log([].constructor === Array) //true 
    // console.log(undefined.constructor) // Error
  </script>
</body>

=======
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <script type="text/javascript">
    /* 
      有以下 3 个判断数组的方法，请分别介绍它们之间的区别和优劣
      Object.prototype.toString.call() 、 instanceof 以及 Array.isArray() 
    */
    // 1. typeof
    typeof ''; // string 有效
    typeof 1; // number 有效
    typeof Symbol(); // symbol 有效
    typeof true; //boolean 有效
    typeof undefined; //undefined 有效
    typeof null; //object 无效
    typeof []; //object 无效
    typeof new Function(); // function 有效
    typeof new Date(); //object 无效
    typeof new RegExp(); //object 无效
   
    // 2. instanceof  检测的是原型
      // instanceof 只能用来判断两个对象是否属于实例关系， 而不能判断一个对象实例具体属于哪种类型。
    function Person() {};
    [] instanceof Array // true
    new Date() instanceof Date; // true
    new Person() instanceof Person;
    [1, 2, 3] instanceof Object; // true
    new Date() instanceof Object; // true
    new Person instanceof Object; // true
    console.log({} instanceof Object)
      // instanceof 存在的问题 来自于不同框架的 array 拥有不同的构造器 这就不能判断啦
    let iframe = document.createElement('iframe')
    document.body.appendChild(iframe)
    xArray = window.frames[0].Array  // window.frames[0]是另外一个页面的window
    xArr = new xArray()
    xArr.push(1, 2, 3) // xArr = [1, 2, 3]
    xArr instanceof Array // false 因为是另一个window的Array构造器创建的数组 

    // 3. Array.isArray() ES5 推出的
    Array.isArray(xArr)  // true 这个方法可以用来判断 不同window下创建的数组
    
    // 4. Object.prototype.toString.call() 都可以判断出来哦
    Object.prototype.toString.call('') ;            // [object String]
    Object.prototype.toString.call(1) ;             // [object Number]
    Object.prototype.toString.call(true) ;          // [object Boolean]
    Object.prototype.toString.call(Symbol());       //[object Symbol]
    Object.prototype.toString.call(undefined) ;     // [object Undefined]
    Object.prototype.toString.call(null) ;          // [object Null]
    Object.prototype.toString.call(new Function()) ;// [object Function]
    Object.prototype.toString.call(new Date()) ;    // [object Date]
    Object.prototype.toString.call([]) ;            // [object Array]
    Object.prototype.toString.call(new RegExp()) ;  // [object RegExp]
    Object.prototype.toString.call(new Error()) ;   // [object Error]
    Object.prototype.toString.call(document) ;      // [object HTMLDocument]
    Object.prototype.toString.call(window) ;        //[object global] window 是全局对象 global 的引用

    // 5. constructor
    /* 
      1. null 和 undefined 是无效的对象，因此是不会有 constructor 存在的，
          这两种类型的数据需要通过其他方式来判断。
      2. 函数的 constructor 是不稳定的，这个主要体现在自定义对象上，
          当开发者重写 prototype 后，原有的 constructor 引用会丢失，constructor 会默认为 Object
     */
    let p = new Person()
    console.log(p.constructor) // ƒ Person() {}
    console.log(p.constructor === Person) // true
    let num = 1
    console.log(num.constructor === Number) // true
    function foo() {}
    console.log(foo.constructor === Function) // true
    console.log(true.constructor === Boolean) // true
    console.log([].constructor === Array) //true 
    // console.log(undefined.constructor) // Error
  </script>
</body>

>>>>>>> a348e00a339fc4441684e34028cd39c7cf1d6d28
</html>