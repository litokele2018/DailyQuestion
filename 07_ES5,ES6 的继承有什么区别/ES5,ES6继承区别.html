<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    /* 
      ES5 的继承，实质是先创造子类的实例对象this，
      然后再将父类的方法添加到this上面（Parent.apply(this)）。
      ES6 的继承机制完全不同，实质是先将父类实例对象的属性和方法，
      加到this上面（所以必须先调用super方法），然后再用子类的构造函数修改this。
      https://es6.ruanyifeng.com/#docs/class-extends
    */



      // ES5   通过原型链向上查找属性和方法
      function Supper() {
        this.name = 'litokele'
      }
      Supper.prototype.setName = function (name) {
        this.name = name
      }
      function Sub() {
        // Supper.apply(this, arguments)
      }

      Sub.prototype = new Supper()    // 继承实例对象    
      Sub.prototype.constructor = Supper
      let s = new Sub()
      console.log('es5 :', s)
      s.__proto__.__proto__ === Supper.prototype // true
      Sub.__proto__ === Function.prototype // true  子类的__proto__ 指向函数的原型

      // ES6

      /* 
        子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类自己的this对象，
        必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，
        加上子类自己的实例属性和方法。如果不调用super方法，子类就得不到this对象。
        注意，super虽然代表了父类A的构造函数，但是返回的是子类B的实例，即super内部的this指的是B的实例，
        因此super()在这里相当于A.prototype.constructor.call(this)
      */
      class Father{
        constructor() {
          this.name = 'litokele'
          this.age = function () {}
        }
        setName(name) {
          this.name = name 
        }
      }
      class Child extends Father{}

      Child.__proto__ === Father  // true 子类的__proto__直接指向 父类
      let c = new Child()
      console.log('es6 :', c)
      // console.log(Father.prototype)
      console.log('子类的prototype: ', Child.prototype)
      console.log('子类实例的__proto__: ', c.__proto__)
      console.log('子类实例的__proto__.__proto__: ', c.__proto__.__proto__)

  </script>
</body>
</html>